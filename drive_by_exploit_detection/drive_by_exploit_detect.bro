redef record Conn::Info += {
  orig_cc: string &optional &log;
  resp_cc: string &optional &log;
};

const dot_regex = /\./;

## Globals
global mime_to_ext: table[string] of string = {
	["text/html"] = "html",
	["text/x-php"] = "php",
	["text/plain"] = "txt",
	["text/javascript"] = "js",
	["application/javascript"] = "js",
};

global debug_mode : bool = F;

global host_cache: table[string] of string &create_expire=5secs;

## Bag of words, lexical properties
type bag_of_words : record {
	length_of_hostname:	int;
	length_of_url:		int;
	number_of_dots:		int;
	url_tokens: string_array;
};

function do_log(msg : string) 
	{
		if(debug_mode)
			{
			print msg;
			}
	}

function do_lexical_analysis(uri_string : string, host : string)
	{
	
	local uri: URI = decompose_uri(uri_string);	
	
	local bow : bag_of_words;

	# Get the length
	bow$length_of_hostname = |host|;
	bow$length_of_url = |host| + |uri|;
	bow$url_tokens = split(host, dot_regex);
		
	# Get number of dot occurrences in host name.
	bow$number_of_dots = |host| - |gsub(host, dot_regex, "")|;
	
	print host;
	print fmt("Number of dots: %s", bow$number_of_dots);

	if(uri?$params)
		{
		local params = uri$params;	
		for ( [ prop ] in params)
			{
			do_log(fmt("%s : %s", prop, params[prop]));
			}
		}
	}

event bro_init()
	{

	}

event http_header(c: connection, is_orig: bool, name: string, value: string)
	{
	# Check if host head exists	
	if(!c$http?$host)
		{
		return;
		}

	local host : string = c$http$host;
	# Create hash of host name
	local host_hash : string = sha1_hash(host);
	if(host_hash in host_cache)
		{
		 # Seen before
		}
	else
		{
		host_cache[host_hash] = host;
		do_lexical_analysis(c$http$uri, host);
		}
	}

event http_request(c: connection, method: string, original_URI: string, unescaped_URI: string, version: string)
	{
	}	

event file_new(f: fa_file)
	{
	
	if(!f?$mime_type)
		{
		return;
		}

	if ( f$mime_type !in mime_to_ext )
		{
		do_log(f$mime_type);
		return;
		}

	local fname = fmt("%s-%s.%s", f$source, f$id, mime_to_ext[f$mime_type]);
	local msg = fmt("Extracting file %s", fname);
	do_log(msg);
	Files::add_analyzer(f, Files::ANALYZER_EXTRACT, [$extract_filename=fname]);
	}

event connection_state_remove(c: connection)
  {
    local orig_loc = lookup_location(c$id$orig_h);
    if ( orig_loc?$country_code )
    	{
    	c$conn$orig_cc = orig_loc$country_code;
  		do_log(orig_loc$country_code);
  		}
    
    local resp_loc = lookup_location(c$id$resp_h);
    if ( resp_loc?$country_code )
    	{
    	c$conn$resp_cc = resp_loc$country_code;
  		do_log(resp_loc$country_code);
  		}
  }